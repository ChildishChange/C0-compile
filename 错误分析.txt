todo：

常量定义：
我需要定义一个符号表
符号表：thetab
索引变量：t
name：在标识符表中的索引
type:0funct1int2float3char
startindex:在表中的位置
endindex：如果是数组，前一个为起始位置，后一个为终止位置
			如果是单个，两个相等


我需要定义一个int数组用来存所有的变量和常量
			float
			char

函数要怎么处理，，是个问题
			
0.所有说明中，出现了未定义的且不是标识符的符号
	即未定义的符号

1.常量说明、变量说明和函数说明顺序混乱的错误
	这样：
	因为这三个是一定要按照顺序来的，因此
	读第一行，如果是const，那就是常量定义
	往下如果是int 那就是变量定义，此时如果出现常量定义就报错
	再往下如果是函数定义，此时如果出现前面两种那就报错
	
2.1常量说明中出现了数组
	大概就是出现了不该出现的符号

2.常量说明中，一次说明多个相同类型的常量时，中间出现了逗号以外的符号
	即此处应为逗号

3.常量说明中，赋值时使用非=的符号
	即此处为=
	
4.常量说明中，重复定义了标识符相同的符号，这个错误还可能出现在其他的地方，所以不管
	即重复定义

5.常量定义没有以分号结尾，如
	const int a = 0，
	const int b = 0，
	即此处应为;

6.常量定义时没有赋值，如
	const int c，
	或
	const int c = ，
	即常量未赋值

7.常量赋值时，等号右边出现了其他的标识符，如
	const int a = b，
	即不能通过表达式给常量赋值
	这个错误有点问题。。
	应该换成：
	此处应为 int
	此处应为 float
	此处应为 char
	这样就可以处理
	const char a = 'a',b = 10;
	这样的错误了，大概
	暂时想不到其他的了。。
	
//变量说明中的错误

8.变量说明中出现了赋值符号
	即出现了不该出现的符号?
	即变量说明中不该赋值？
	
9.跟常量一样
	即此处应为，
	即此处应为;
	即重复定义
	即未定义的符号

10.定义数组时
	即此处应为方括号，具体哪个我先不管

11.方括号内部不是int
	即此处应为int
定义函数时，入口跟变量说明是一样的，但是判断条件是小括号
这样的话，可以根据预读的这一行里是否有小括号，来判断是进入还是进入。。
并不行。。这样如果一行同时定义变量和函数那就GG
所以我觉得只能在variadec里调用funct,随后return
	这样只能处理有返回值的函数，因此出现了void就断了，因此还要在main中
	再添加一个funct
这样的话就需要给funct加参数

	//函数定义时的错误

12.main函数后还有函数

13.main函数有返回值

14.跟其他情况一样
	此处应为小括号
	此处应为大括号
	此处应为逗号
	
/*======================================================*/
10:14
常量定义时可能出现有符号和无符号的情况

float可能出现两个符号的情况

比起这个我更想知道怎么处理表达式。。。。

14：39
如果是void函数，用普通的方法就可以解决了

如果是有返回值的函数，只能在变量说明里调用

这么说我可以写两个函数
functwith
在有返回值的时候，即在varia中调用，在内部读到了之后再调用
functwithout	
即在读入void后调用
如果读入了int，然后再调用functwith

参数不能是数组，开心
调用with的时候是因为已经读入了   int + 标识符，此时读到了小括号
with可以带参数
（int kind，char name【】）
{
	
	switch kind
	{
		case1：
			这里打印不同种类的函数吧。。
		case2：
	}
	puts函数名为
	读取参数表
	循环直到读入）
	读大括号
	statement_s
	循环直到最后一个大括号
	读，循环直到读完所有的有返回值函数
	
}
without
{
	没有case了
	读函数名，如果是main
	都参数表
	读大括号
		读复合语句
	读大括号
	读，如果是int
	再读一个，
	再度一个
	调用with
	
}


19:06
int 
	if(n==0)
	{
	会被处理成函数
	
	
21：26
出现了一个问题。。。
expression在调用之前是否需要预读一个。。
我觉得还是预读一个吧。。。


getch一次缓冲一行
getsym并没有预读
constdec调用前都一个const ，最后需要预读一个才判断是否结束函数
variadec调用前不预读，最后需要预读3个单词判断是否是有返回值函数，否则直接退出
在函数体内调用则是预读了一个
functwith调用前预读3个单词
functwithout同调用前预读3个单词，还没写完
paralist 0，最后读完了）才判断终止
compoundstatement 在funct里读了一个大括号之后才调用这个，理论上没有预读
入 没有预读
statement_s
入 预读了一个
statement//预读了一个。。。真是太好了。。
入 预读了一个
scanfstatement

printfstatement
ifcondition
入 预读一个if
expression//强制规定调用之前要预读一个,
目前我是默认跳出不会预读。。但是肯定有问题。
因为需要预读一位
term默认term之前要预读
默认跳出term不语都
不，跳出term也预读了
factor默认预读一个
因为expression

<项>=> <因子>{<乘法运算符><因子>}
								
<因子>=> 
<标识符>|出来之前预读了一个
<标识符>'['<表达式>']'|
//<有返回值函数调用语句>|//
<标识符>'('<值参数表>')'
<整数>|出来之前预读一个
<实数>|出来之前预读一个
<字符>|

'('<表达式>')'  


处理正负号应该设置一个全局变量
另外printf内嵌套表达式没有处理好



/*===============================================*/

语句的结束符号有很多欸。。
语句的结束符号有分号和大括号

问题来了语句列并没有结束符号，

调用与剧烈的复合语句的结束符号是大括号

PL0在出这个语法成分之前都会预读下一个语法成分。


语句读完分号

/*=============================================*/
编译到了print

/*=============================================*/
符号表
符号表的作用：
声明常量时：
	查表
	插表
	赋值
在声明变量时
	查表
	插表
声明函数时
	查表
	
	
额
不能定义同名的函数
标识符不区分大小写
函数内部定义的变量可以覆盖掉全局常、变量，仅在这个函数体内


 int a;………………………………………………………1

a=100;……………………………………………………2

int addfunction(int m,int n)………………………………3

{

return (m+n);………………………………………………4

}

void main()…………………………………………………5

{

int b，c;……………………………………………………6

b=200;………………………………………………………7

c=addfunction(a,b);…………………………………………8

printf(c);.............................................................9

} 
 
struct SymbolTable
{
 
 char name[20];//符号名称
 
 
 int kind;//符号种类  常量|变量| 函数
 
 int type; //常量、变量类型 int| float| char | void
 
 int level; //符号所在层次，或者叫作用域
  
 int address;//符号地址
 }globalTable[3000];//全局符号表

int globalTableaddress=0;    //记录最新添加的符号表项的位置

struct ConstTable
{
 double i;
 char j[200];
}constTable[500]; //常量表    
int constTableadd=0;

struct localTables
{
 
 char name[20];//函数名
 
 
 struct SymbolTable localtable[300];//函数参数及局部变量、常量
}localTable[50]; //局部符号表

常量表，全局符号表，局部符号表




/*===============================*/
符号表设计
符号表中的ref是用于指向数组或函数表的
符号表中的adr是用于指向运行栈的
全局变量一开始就可以设置运行栈
其他常量一开始只用存值

数组表，这个没什么特殊的
存数组大小和元素类型，查找某个数组元素时用来找在符号表中的位置

函数表，begin和end分别对应这个函数内的变量在符号表中的位置
但是。
我想把全局变量设置为第一个函数
就是说函数表的第一项的begin是第一个全局量，
函数表的第一项的第一个end是最后一个全局量

关于什么时候让这些表的下标加一的问题

关于判断现在是在函数中还是在全局中建立变量的问题
就是关于查表的问题
在全局变量中填表，填表之前只要从0开始顺序找，找有没有重复定义的
定义新函数时，也是查找所有变量中是否有

关于重名问题
全局量
局部量
函数名
1.全局量之间
不行，在查表时直接从零往下查
2.同一个函数的局部量之间
不行，在查表时直接从这个函数名往下查
3.不同函数的局部量之间
可以，查表时只查这个函数内的
4.函数和函数之间
不行，查表时只查全局量和函数名
5.全局量和局部量
可以，局部量覆盖全局量
6.全局量和函数名
不行，从头往下查
7.函数和该函数内的局部量
可以，查表时只查从这个函数开始的所有局部量
8.函数和另一个函数内的局部量
可以，

所以在查表时，有点麻烦。。。
1.如果是常变量定义
	如果是全局量定义
	如果是非全局量定义
	：
	如果当前函数表下标为零，说明仍在定义全局量，
		此时只查找函数表下标对应的元素中对应的范围
		
	如果当前函数表下标非零，说明已在定义函数内的局部量
		此时只查找当前函数表下标对应的范围中非函数的部分
		
	
2.如果是函数定义
	如果当前函数表下标为零，说明仍在定义全局量，目前这个函数是第一个函数
		此时只查找函数表下标对应的元素中对应的范围
	如果当前函数表下标为非零，说明已经定义了函数
		此时只查找全局量和所有函数名是否有同名项

3.如果是调用量
	先在当前函数中查，再到全局量中查
4.如果是调用函数
	往前查函数表

Stab

globalTab
globalTabAddr存一个量之后加一
functT
functTAddr,因为第一个用来存变量，所以村一个之前加以
arrayT
arrayTAddr

上面的34抛弃掉，重写一个好了。。

欧也，建表查重写好了，
==================================================
添加符号表
所有的都先用全局变量存者
==================================================
昨天遗留了一个玄学bug，好吧其实并不玄学
==================================================
今天设计指令了
<语句>=> <条件语句>
		if condition then
		[else]
		<condition>

if()	condi

else

if()
		
		|<空>;
		什么都不生成
		|<读语句>;
		|<写语句>;
		|<返回语句>;
		|<循环语句>
		|'{'<语句列>'}'
		
		|<有返回值函数调用语句>; 
		|<无返回值函数调用语句>;
		|<赋值语句>;

首先
const enum fct  {LOD = 1,LIT 2,STO 3 ,JMP 4,JPC 5,OPR 
				6,CAL 7,INT 8,RED 9,WRT10};
		
指令表	操作数1	操作数2	意义
LOD	1，2	a	1取出运行栈中地址为a的元素的值2取出符号表中地址为a的元素
LIT	0	a	将栈顶元素置为a 1int 2float 3char, 设三个参数
STO	0	a	将栈顶元素存入运行栈中地址为a的元素中
JMP	0	a	pc = a，跳转至指令表中下标为a的地方
JPC	0	a	pc=a
OPR			取反
			+
			-
			*
			/
			==
			>=
			<=
			<
			>
			!=
			？0
			需要一个返回的
			需要一个返回值的
CAL	0	a	取函数表中的第a个元素
INT			栈顶指针增加a
RED			读数据并存入运行栈中地址为a的元素中
WRT			输出栈顶元素
			输出字符串表中地址为a的元素

<表达式>=> [+|-]<项>{<加法运算符><项>}
					<关系运算符>=>  <|<=|>|>=|!=|==

						<项>=> <因子>{<乘法运算符><因子>}								
							<因子>=> 
							<标识符>|
							<标识符>'['<表达式>']'|
							<标识符>'('<值参数表>')'|
							上面是有返回值调用函数
							<整数>|
							<实数>|
							<字符>|
							'('<表达式>')'  
							
							
<语句>=> <条件语句>
							|<读语句>;
							|<写语句>;
							|<返回语句>;
							|<循环语句>
							
							|'{'<语句列>'}'
							
							|<有返回值函数调用语句>; 
							|<无返回值函数调用语句>;
							|<赋值语句>;
							

	
指令名	操作数1	操作数2	进行的操作									
LOD	1	a	栈顶指针++取出运行栈中地址为a的元素的值于栈顶									
	2	a	栈顶指针++取出符号表中地址为a的元素的值于栈顶
	这个a通过查表就可以查到了。。
	改了。。于是现在
	
LIT	1		栈顶指针++将栈顶置为int a							
	2		栈顶指针++将栈顶置为float a									
	3		栈顶指针++将栈顶置为char a
	这个a是自己设置的。。
	
	
STO	0	a	将栈顶的值存入运行栈中地址为a的元素中，栈顶指针--	
这个GG，这个显然只用于赋值语句
关于赋值语句要存到哪里的问题的a怎么获得的问题：	
	a是查表查出来的，如果是变量赋值，这个好查，先用表达式，这个时候栈顶是这个变量的值
	然后查表，得到a
	然后STO 0 a
	
	如果是数组中某一项赋值，这个GG，
	调用expression，这时在栈顶应该有另一个值，是偏移量,然后栈顶元素加上查表的返回值，现在栈顶是地址
	然后等号之后又是expression，算出值来，值在栈顶，新建一个指令叫做 STOR 0 0：把栈顶元素的值存到栈顶元素下的值指向的运行栈的位置里
	栈顶减两次
								
JPC	0	a	判断栈顶元素是否为0，为零则顺序执行，否则next pc设为代码表中地址为a的代码
JMP 0	a
这两个J的a都很难，据说要用一个栈									
OPR	1	a	将栈顶元素取反									
	2	a	将栈顶元素加上它下面那个元素，存到下面那个元素里，栈顶指针--									
	3	a	将栈顶元素剪去它下面那个元素，存到下面那个元素里，栈顶指针--									
	4	a	将栈顶元素乘以它下面那个元素，存到下面那个元素里，栈顶指针--									
	5	a	将栈顶元素除以它下面那个元素，存到下面那个元素里，栈顶指针--									
	6	a	判断栈顶元素是否为0，为零则顺序执行，否则next pc设为代码表中地址为a的代码									
	7	a										
	8	a										
	9	a										
	10	a						
这个a很简单	
												
CAL 	0	a	取入口地址为a的指令	
先查函数表，获得入口代码地址，然后开始执行								
INT	0	a	栈顶指针增加a									
RED	1	a	读数据存入运行栈中地址为a的元素中									
	2											
	3										
因为只能是标识符所以所以你说呢。。
查表阿 	
WRT	1	a	输出栈顶元素									
	2	a	输出字符串表中地址为a的元素									
	这个a是怎么来的。。读入一个字符串，压到字符串表里，然后马上跟着生产一条指令
  1	  2	  3	  4	  5	  6	  7	  8   9	  10  11   12
{LOD,LIT,STO,JMP,JPC,OPR,CAL,INT,RED,WRT,LOAD,STOR};

0       INT     0       3.000000

1       INT     0       3.000000
2       LIT     1       5.000000

3       INT     0       3.000000

4       LIT     1       2.000000
5       INT     0       1.000000
6       LIT     0       5.000000
7       OPR     0       2.000000

8       CAL     0       1.000000
9       STOR    0       0.000000

10      CAL     0       1.000000
11      INT     0       1.000000
12      LIT     0       5.000000
13      OPR     0       2.000000

14      LIT     1       6.000000
15      STOR    0       0.000000

16      WRT     2       0.000000

17      LIT     1       6.000000
18      INT     0       1.000000
19      LIT     0       5.000000
20      OPR     0       2.000000
21      LOAD    0       0.000000
22      WRT     1       0.000000

23      RED     0       0.000000
24      RED     0       0.000000

25      LIT     1       0.000000
26      STO     1       0.000000

27      LOD     1       0.000000
28      LIT     1       1.000000
29      OPR     0       3.000000
30      STO     1       0.000000

31      LOD     1       0.000000
32      LOD     1       0.000000
33      OPR     0       3.000000
34      STO     1       0.000000

35      LOD     1       0.000000
36      LOD     1       0.000000
37      LOD     1       0.000000
38      OPR     0       4.000000
39      OPR     0       3.000000
40      STO     1       0.000000
41      LOD     1       0.000000
42      LOD     1       0.000000
43      OPR     0       3.000000
44      LOD     1       0.000000
45      OPR     0       4.000000
46      STO     1       0.000000
47      LIT     1       0.000000
48      STO     0       0.000000
49      LOD     1       0.000000
50      INT     0       1.000000
51      LIT     1       100.000000
52      OPR     9       0.000000
53      JPC     0       65.000000
54      LOD     1       0.000000
55      LIT     0       1.000000
56      OPR     0       2.000000
57      STO     1       0.000000
58      LOD     1       0.000000
59      LOD     1       0.000000
60      OPR     0       4.000000
61      LOD     1       0.000000
62      OPR     0       3.000000
63      STO     1       0.000000
64      JMP     0       49.000000
65      LOD     1       0.000000
66      INT     0       1.000000
67      LIT     1       100.000000
68      OPR     7       0.000000
69      JPC     0       99.000000
70      LOD     1       0.000000
71      LIT     1       1.000000
72      OPR     0       3.000000
73      STO     1       0.000000
74      LOD     1       0.000000
75      INT     0       1.000000
76      LIT     1       5.000000
77      OPR     6       0.000000
78      JPC     0       84.000000
79      LOD     1       0.000000
80      LIT     1       100.000000
81      OPR     0       4.000000
82      STO     1       0.000000
83      JMP     0       98.000000
84      LOD     1       0.000000
85      LIT     1       100.000000
86      OPR     0       3.000000
87      STO     1       0.000000
88      LOD     1       0.000000
89      INT     0       1.000000
90      LIT     1       100.000000
91      OPR     9       0.000000
92      JPC     0       98.000000
93      LOD     1       0.000000
94      LIT     1       1.000000
95      OPR     0       3.000000
96      STO     1       0.000000
97      JMP     0       88.000000
98      JMP     0       65.000000



TODO:值参表的传递，没有判断数字
TODO:最后一个函数没有修改end
TODO:修改行缓冲
TODO:输出PCODE时
TODO:一个神一样的BUG
TODO:错误处理能不能用goto呢

0       INT     0       3.000000
1       INT     0       3.000000
2       LIT     1       5.000000
3       INT     0       3.000000
4       LOD     1       0.000000
5       LIT     1       1.000000
6       OPR     0       3.000000
7       INT     0       3.000000
8       LIT     1       2.000000
9       INT     0       1.000000
10      LIT     0       8.000000
11      OPR     0       2.000000
12      CAL     0       0.000000
13      STOR    0       0.000000
14      CAL     0       0.000000
15      INT     0       1.000000
16      LIT     0       8.000000
17      OPR     0       2.000000
18      LIT     1       6.000000
19      STOR    0       0.000000
20      CAL     0       1.000000
21      LOD     1       0.000000
22      STO     0       0.000000
23      LOD     1       0.000000
24      STO     0       0.000000
25      STO     1       0.000000
26      WRT     2       0.000000
27      LIT     1       6.000000
28      INT     0       1.000000
29      LIT     0       8.000000
30      OPR     0       2.000000
31      LOAD    0       0.000000
32      WRT     1       0.000000
33      RED     0       0.000000
34      RED     0       0.000000
35      LIT     1       0.000000
36      STO     1       0.000000
37      LOD     1       0.000000
38      LIT     1       1.000000
39      OPR     0       3.000000
40      STO     1       0.000000
41      LOD     1       0.000000
42      LOD     1       0.000000
43      OPR     0       3.000000
44      STO     1       0.000000
45      LOD     1       0.000000
46      LOD     1       0.000000
47      LOD     1       0.000000
48      OPR     0       4.000000
49      OPR     0       3.000000
50      STO     1       0.000000
51      LOD     1       0.000000
52      LOD     1       0.000000
53      OPR     0       3.000000
54      LOD     1       0.000000
55      OPR     0       4.000000
56      STO     1       0.000000
57      LIT     1       0.000000
58      STO     0       0.000000
59      LOD     1       0.000000
60      INT     0       1.000000
61      LIT     1       100.000000
62      OPR     9       0.000000
63      JPC     0       75.000000
64      LOD     1       0.000000
65      LIT     0       1.000000
66      OPR     0       2.000000
67      STO     1       0.000000
68      LOD     1       0.000000
69      LOD     1       0.000000
70      OPR     0       4.000000
71      LOD     1       0.000000
72      OPR     0       3.000000
73      STO     1       0.000000
74      JMP     0       59.000000
75      LOD     1       0.000000
76      INT     0       1.000000
77      LIT     1       100.000000
78      OPR     7       0.000000
79      JPC     0       109.000000
80      LOD     1       0.000000
81      LIT     1       1.000000
82      OPR     0       3.000000
83      STO     1       0.000000
84      LOD     1       0.000000
85      INT     0       1.000000
86      LIT     1       5.000000
87      OPR     6       0.000000
88      JPC     0       94.000000
89      LOD     1       0.000000
90      LIT     1       100.000000
91      OPR     0       4.000000
92      STO     1       0.000000
93      JMP     0       108.000000
94      LOD     1       0.000000
95      LIT     1       100.000000
96      OPR     0       3.000000
97      STO     1       0.000000
98      LOD     1       0.000000
99      INT     0       1.000000
100     LIT     1       100.000000
101     OPR     9       0.000000
102     JPC     0       108.000000
103     LOD     1       0.000000
104     LIT     1       1.000000
105     OPR     0       3.000000
106     STO     1       0.000000
107     JMP     0       98.000000
108     JMP     0       75.000000




================================================

adr中还是存相对基地址的偏移量好了
调用函数时，栈顶指针要根据函数变量增加
取局部变量
取基地址偏移量
取全局变量
直接取地址
上面这个两个好说，LOD 加个参数的事
取局部常量
这个也好说，也在符号表里找
取全局常量
这不是一样吗。。。。
现在的问题是，因为我的常变量定义用的是同一个函数，即在函数内不能分辨是全局还是局部。。。
好吧，还是有的，看函数表指针
当函数表指针显示是全局的时候，就直接分配地址
当函数表指针是局部的时候，就只传递偏移量

存全局变量
存地址偏移量
存局部变量
直接存地址

取标识符我用的是LOD
LOD 操作数1 操作数2
操作数1代表
1.取全局常量
对应的操作数2
只能对应在符号表中的位置
2.取全局变量
这里则是在运行栈中的位置
3.取局部变量
这里则是相对基地址的偏移量，需要一个基地址指针
4.取局部常量
同理，只能对应在符号表中的位置


STO 操作数1 操作数2
1：
存局部变量
2：
存全局变量


好吧现在的问题是我的查找函数并不能返回这个是以上哪种类型

所以要改searchident
因为这个函数只有在使用变量时才会查。。
尴尬了。。
好吧可以修改返回值
然后添加一个全局变量用来存原来的返回值，只有当返回值不为-1时才会

取立即量是LIT


TODO:
又有一个新的bug：
如果在定义一个函数时，它跟之前的函数重名了，则这个函数内部的未定义调用不能被识别
因为在检查出函数重名之后这个函数不会被定义。。但是之后的东西会顺序执行

好像有一个新的bug
如果有全局量，则第

修改使用到searchident函数的地方
修改searchident函数

然后修改变量定义的函数
在变量定义时检查此时文件指针，
如果全局
	如果常量
		还是存值，不管
	如果变量
		分配一个栈地址，对的，此时有一个变量用来存东西了
		
如果局部
	如果常量
		存值，不管
	如果变量
		不分配栈地址，只存一个偏移量
		
如果常量
	全局
	局部 都一样 不用改
如果变量
	全局 ，存的都是基地址
	局部 修改符号表的adr为偏移量
	如果是数组。。。。